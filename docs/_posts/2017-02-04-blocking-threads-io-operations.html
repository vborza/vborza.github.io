--- 
layout: post 
title: Don't block your threads with IO bound operations
permalink: /blocking-threads-io-operations/
tags:
  - csharp
  - async
comments: true
image: /img/posts/wire-birds.jpg
---

<p>
Many of us use the <em>async/await</em> feature in C# projects, as we know the benefits of asynchronous programming related to IO bound operations. 
But did you ever look under the hood to check what's going on in your app's threads? 
In this post we will diagnose a sample app, monitoring it's threads behavior when using sequential, parallel and asynchronous code. 
<!--more-->
</p>

<p>
The purpose of our sample console app is to download some pages from the internet. In the real world example, we would probably parse them and 
process the information somehow. To keep our example simple, instead of downloading 10 various pages, we just download the  page <a href="http://vborza.com/blog">http://vborza.com/blog</a>
10 times. We will diagnostic the threads' behavior with <a href="https://msdn.microsoft.com/en-us/library/dd537632(v=vs.120).aspx">Concurrency Visualizer</a> - 
an optional extension for Visual Studio.
<br>

<div class="headline"><h4>Sequential approach</h4></div>

<p>
At first, we use the usual sequential approach as below:
{% highlight csharp %}
for (var i = 0; i < 10; i++)
{
    using (var webClient = new WebClient())
    {
        var response = webClient.DownloadString("http://vborza.com/blog");
    }
} 
{% endhighlight %}  

After we run Concurrency Visualizer analysis on our application, an useful report with information about CPU utilization and threads is generated.
First thing we can check is how long the program run - in this case, it was <b>3744 ms</b>. CPU utilization page shows how much CPU capacity was used. 
We can see, that the biggest load is on the app's startup and then there are small peaks as the requests are being sent and responses are processed.  
</p>

<a href="{{site.url}}/img/posts/sequential_requests_processor.png" target="_blank">
    <img class="img-responsive center" style="border: solid 1px #bbb;" src="{{site.url}}/img/posts/sequential_requests_processor.png" alt="">
</a>
<br>
<p>
When we take a look on threads view, we can see that the CPU's peaks correlate with execution parts (<span style="color:green;">green color</span>) on the main thread. 
It's obvious that all the operations run on main thread, where the execution blocks alternate with IO bound blocks (<span style="color: purple">purple color</span>). 
We can see that <b>most of the time the main thread is blocked, <em>synchronously</em> waiting for completion of the IO operations (the HTTP requests)</b>.
</p>

<a href="{{site.url}}/img/posts/sequential_requests_threads_3744.png" target="_blank">
    <img class="img-responsive center" style="border: solid 1px #bbb;" src="{{site.url}}/img/posts/sequential_requests_threads_3744.png" alt="">
</a>
<br>
<blockquote>
    <p><em>As you can see, beside the main thread there are more threads in the report. However, they are not used by the app. They are either the
        threadpool threads or they are bound to debugger and concurrency visualizer sessions.</em> 
</blockquote>

<div class="headline"><h4>Parallel approach</h4></div>
<p>
The application obviously works, but let's say that our manager is unhappy with it's performance. He want to make it quicker. We examine the code and because 
downloading a web page is an independent operation, we decide to make the calls in parallel.

{% highlight csharp %}
Parallel.For(0, 10, i =>
{
    using (var webClient = new WebClient())
    {
        var response = webClient.DownloadString("http://vborza.com/blog");
    }
});
{% endhighlight %}  
<blockquote class="hero">
    <p><em>I had not used <code>new Thread(() => ..).Start()</code> as it is considered as bad practice nowadays. It forces new thread creation,
    which takes cca 200 000 cycles on processor, and another 100 000 when disposing the thread. Except of some special cases, it's wrong when 
    you create new threads in your application this way. By default you should use methods from Task Parallel Library, which operates on threadpool 
    and provides far more efficient use of system resources.</em> 
</blockquote>

Let's take a look on information from Concurrency Visualizer. Now the program execution took <b>1757 ms</b>, which is quite an improvement. 
We can also see that the engine utilization peaks are higher than in the sequential version, especially after application's start, when the requests 
for downloading the page are being sent in parallel. As there is also some thread switching overhead (obviously on 4 cores machine just 4 threads can run in the same moment) 
and some responses are processed in parallel, the bigger cpu utilization makes sense. 
</p>

<a href="{{site.url}}/img/posts/parallel_requests.png" target="_blank">
    <img class="img-responsive center" style="border: solid 1px #bbb;" src="{{site.url}}/img/posts/parallel_requests.png" alt="">
</a>
<br>

<p>
The threads section from the report reveals even more details about parallel execution. As you can see, beside the main thread the majority of the 
execution was delegated to 4 others Common Language Runtime Worker threads. For that reason, the program was executed quicker. However, as in the 
sequential execution case, most of the time the threads does not execute any CPU bound work - they are blocked by waiting on completion of IO bound 
<code>webClient.DownloadString</code> operations.
</p>

<a href="{{site.url}}/img/posts/parallel_threads_1757ms.png" target="_blank">
    <img class="img-responsive center" style="border: solid 1px #bbb;" src="{{site.url}}/img/posts/parallel_threads_1757ms.png" alt="">
</a>
<br>

<div class="headline"><h4>Giving a try to asynchronous code</h4></div>

<p>
So we fixed the issue with the speed of the application and it worked well. However, after some time a new requirement for downloading thousands of pages 
emerged. Testing with this number of pages shows that our simple console app consumes much more
resources (threads and time) than it should. The cause is clear - with increasing number of parallel HTTP requests grows also the 
number of threads in the app. As they are synchronously waiting for completion of the IO operation, they cannot be reused for other work and 
new threads has to be created. Intense thread switching doesn't help the performance either. <br> 
What is the solution for this problem? Asking the project manager for bigger operation memory and better CPU?
No, there is much better improvement we can do to make our app<b> more scalable - downloading the pages in asynchronous way</b>. We can rewrite the code 
in following way.

{% highlight csharp %}
using (var webClient = new HttpClient())
{
    var tasks = new Task[10];
    for (var i = 0; i < 10; i++)
    {
        tasks[i] = webClient.GetStringAsync("http://vborza.com/blog");
    }
    Task.WhenAll(tasks).Wait();
}
{% endhighlight %}  

As you can see from the code, we are still executing the requests in parallel, but in asynchronous manner.
<blockquote class="hero">
    <p><em>I used <code>Wait()</code> method instead of <code>await</code>, as this code is running in <code>Main</code> method of console application, 
    which is synchronous. Thus I am synchronously blocking the main thread, waiting for all async tasks to complete. However, it's still better than blocking 
    all threads with IO operations.</em> 
</blockquote> 
</p>

<p>
After running analysis in this code snippet, we can see some improvements comparing to previous parallel execution. We got slightly better execution time - 
<b>1353 ms</b>. Also CPU utilization graph shows that it's usage is more balanced than with <code>Parallel.For</code> version.
</p>

<a href="{{site.url}}/img/posts/async_parallel_cpu.png" target="_blank">
    <img class="img-responsive center" style="border: solid 1px #bbb;" src="{{site.url}}/img/posts/async_parallel_cpu.png" alt="">
</a>
<br>

<p>
What interests us the most is the behavior of threads. We can see, that the percentage of IO operations was reduced to 1% (from previous 25%).
In the reality the improvement is even better, as the report shows also threads that our app don't operate with. As in the previous case, the 
work was delegated mainly to main thread and other 4 CLR Worker threads.</b>
</p>


<a href="{{site.url}}/img/posts/async_parallel_threads_1353ms.png" target="_blank">
    <img class="img-responsive center" style="border: solid 1px #bbb;" src="{{site.url}}/img/posts/async_parallel_threads_1353ms.png" alt="">
</a>
</br>


<p>
The most important difference is that <b>the threads are no longer waiting for completion of IO bound operations, but they are released back to 
the thread pool. This way they can be reused by other CPU bound operations.</b>
</p>


