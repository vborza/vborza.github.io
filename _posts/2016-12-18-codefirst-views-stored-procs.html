--- 
layout: post 
title: EF Code First - Views and Stored Procedures
permalink: /codefirst-views-stored-procs/
tags:
  - csharp
  - ef
comments: true
image: /img/posts/orm_vs_views_and_sp.png
---

<p>
Programming an application with <em>Entity Framework</em> and <em>Code First</em> does not mean you won't write any raw SQL anymore.
C# code is great for the basic CRUD operations, but as the application grows, there are cases when you need to write complex queries containing various
joins (on multiple columns) and aggregate functions<!--more-->, or you need to do some huge
bulk updates. These are the situations, when you don't want to rely on SQL generated from LINQ and you 
rather create a view or a stored procedure, using all the power of SQL Server to improve its performance.
</p>

<img class="img-responsive center" style="margin: auto;" src="{{site.url}}/img/posts/power_raw_sql.jpg" alt=""></br>

<p>
Let's suppose that you were given an assignment to develop a simple application, which should basically work only with couple of entities and 
performing some CRUD operations.<br>
You have decided to go with <em>Entity Framework</em> and <em>Code First</em> approach, as it's easy to use and speeds the development up. 
Everything runs smoothly and you get by with only writing LINQ queries and using basic Entity Framework's functions. But as the application 
and its database grows, there come new requirements for dashboards displaying various statistics on the top of your data. 
<br>
You start working on LINQ query for the first dashboard, which requires joins on more than 5 tables, subqueries and various aggregate functions. 
As you write the 20th line of code of your LINQ query, struggling to make it work, you realize that it may be cleaner and more efficient to write a 
database view or a stored procedure. This way you could use temp tables and another features 
of your database server (cached execution plans), to improve the responsiveness of your dashboards.</p>
<p>
We will take a look how to handle this situation in the way, that it will play nicely with <em>Entity Framework</em> 
and <em>Code First</em> approach.
</p>
<!--more-->

<div class="headline"><h4>Dealing with a Database View</h4></div>
<p>
Using a database view is handy when you need to reuse its rows in multiple queries. You can map a database view to an entity in your database context,
so you can treat it as a regular table in your LINQ queries.
</p>
<p>
Steps to handle a view:
<ol>
    <li>
        Create a <code>SomeEntityVw</code> class with properties mapped to view columns. You can use EF features like virtual properties and <code>ForeignKey</code> 
        annotations to be able to load entities related to the view in your queries.
    </li>
    <li>
        Add the created entity as a new property <code>DbSet&ltSomeEntityVw&gt SomeEntitiesVw</code> to your database context.
    </li>
    <li>
        Add new migration using <em>Package Manager Console</em> and <code>add migration</code> command.
    </li>
    <li>
        As you can notice, the generated migration contains statements for creating a new table for the <code>NewEntityVw</code> 
        in the <code>Up()</code> method. 
        Delete this code and replace it with <code>Sql(@"CREATE VIEW dbo.vwSomeEntities AS...")</code> statement. <br>
        You should also replace the code in the <code>Down()</code> method to be able to revert the migrations properly. Its code should contain call to 
        <code>Sql(@"DROP VIEW dbo.vwSomeEntities;")</code>.
    </li>
    <li>
        Update the database.
    </li>
</ol>
Now you can use the new entity in your LINQ statements as it were a regular table (e.g. <code>dbContext.SomeEntitiesVw.Where(x =>..)</code>).
</p>
<p>
<blockquote class="hero">
    <p><em>Of course, when you try to update some properties in the entity mapped to a view, a call to <code>saveChanges()</code> 
    will fail, unless you create a writable view, which is quite rare. For that reason you should give the entities which are mapped to views some specific names,  
    to make clear that they should not be updated (e.g. their names should end with 'Vw').</em> 
</blockquote>	
</p>

<div class="headline"><h4>Using a Stored Procedure</h4></div>
<p>
In some cases, a stored procedure is more suitable than a database view. Imagine a scenario when you have to show some complex statistics for a 
concrete user. Using a sql view, you would have the rows with statistics for all the users generated. Then you will have to call 
<code>Where(x => x.UserId = id)</code> statement in the code to get the row for the related user. As there would be many joins and group by clauses 
in the all users statistics view, it will take much more time as creating the statistics for just one user.<br>
Probably more efficient would be a parametrized stored procedure with <code>@userid</code> parameter. This way, you could filter the rows directly 
when joining the tables using clauses like <code>join on t1.userid = @userId</code>. This way only the rows for the given user will be processed by SQL Server.</p>
<p>
Another common scenario where stored procedures beat ORM frameworks are bulk updates and deletes. In Entity Framework we need to 
load the objects to the memory first, then we update or delete them and call <code>dbContext.SaveChanges()</code> to promote the changes to database. 
This is very inefficient when you deal with thousands of rows and stored procedures handle these use cases much better.</p>
<p>
How to create a stored procedure?
<ol>
    <li>
        Add a new (empty) migration to your project.
    </li>
    <li>
        Add code to the <code>Up()</code> method as <code>Sql(@"CREATE PROCEDURE dbo.spUserstatistics @userId int ...")</code><br>
        Implement the <code>Down()</code> method's body with <code>Sql(@"DROP PROCEDURE dbo.spUserstatistics;")</code>
    </li>
    <li>
        Update the database
    </li>
</ol>
</p>
<p>
How to call the stored procedure?

<ol>
    <li>
        If your stored procedure returns a result set, create a class that match the columns of the returned table, e.g. <code>SpResult</code>.<br>
        Then call the stored procedure as 
{% highlight csharp %}using (var context = new DbContext()) 
{ 
     var result = context.Database.SqlQuery<SpResult>("dbo.spUserstatistics @userId", 
                     new SqlParameter("@userId", id)).FirstOrDefault(); //or .ToList() 
} 
{% endhighlight %}
    </li>
    <li>
        If your stored procedure does not return a result set, only some value like success code, number of updated rows, etc. 
        (it has a <code>RETURN</code> statement instead of <code>SELECT</code>), then you can call it as follows
{% highlight csharp %}
using (var context = new DbContext()) 
{ 
    var returnCode = new SqlParameter("@returnCode", SqlDbType.Int);
    returnCode.Direction = ParameterDirection.Output;

    context.Database.SqlQuery<object>("exec @returnCode = dbo.spBulkUpdateUserRecords @userId", 
                                returnCode, new SqlParameter("@userId", id)).FirstOrDefault(); 
    var returnCodeValue = (int)returnCode.Value;
} 
{% endhighlight %}
    </li>
</ol>
</p>

<div class="headline"><h4>Deployment</h4></div>
<p>
Using the migrations, your database views and stored procedures are deployed to the SQL Server the same way as the migrations for the tables,
which were generated automatically from your code. This way, you don't need to use any additional mechanism for deploying your SQL scripts. More importantly,
with properly written migrations (<code>Down()</code> methods implemented correctly), 
you can still use features of code-first migrations like reverting the database schema to a specific state, 
which is a huge benefit.
</p>
<div class="headline"><h4>Unit Testing</h4></div>
<p>
There is one important thing we <b>loose</b> when we use raw SQL instead of LINQ - <b>full type and error checking at compile-time</b>. When you have a stored procedure or a view
defined on database level, your code will compile without errors even if you delete/modify the tables which the stored procedure or view operates on. For that
reason it is very important to have unit tests also on database level, permanently checking that your views and stored procedures works as expected.
If some of your tests starts failing and you detect that some stored procedure or view has to be updated, create a migration with proper <code>Sql("ALTER...")</code> statement 
before deploying the application.
</p>
<p>
<blockquote class="hero">
    <p><em>If you are interested how to easily setup data access tests on a testing database with the same context and schema as your app has,
        check my post <a href="{{ site.url }}/{% post_url 2016-12-04-ef-database-testing %}">Entity Framework & Database Testing </a> for more details</em>. 
</blockquote>	
</p>

